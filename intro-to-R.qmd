# Rの基本操作

**今回の目標**

-   Rの基本的な使い方を身につけよう！


## Rの基礎 {#sec-rbasic}

RのコードはRのConsoleに直接入力してもよいし、スクリプトに保存してRから呼び出してもよい。スクリプトを使うときは、スクリプトファイルを**file_name.R** のように **.R** ファイルとして保存する。そして、RのConsole で `source("file_name.R")` とすれば、スクリプト全体が実行される。

:::callout-important
この資料にあるコードは簡単にコピーすることができる。それをR (RStduio) にペーストすれば（貼り付ければ）コマンドを実行することができる。
しかし、そのような方法ではなかなかコマンドを覚えることができないだろう。

**Rのコマンドは、自らの手でタイプすることを強く勧める。プログラミングを身につけるためには、自分でプログラムを「書く」ことが必要である。**
:::


Rコマンドの区切りは改行である。改行すれば、1つのコマンドが終了したと認識される。

```{r}
35 + 87
```

ただし、括弧が閉じていなかったり、行末に二項演算子 (`+` や `*` など) があるときは、コマンドが次の行まで続いていると認識される。

```{r}
35 +
    87
```

1行に複数のコマンドを書きたいときは `;` で区切る。

```{r}
35 + 87; 25 * 4
```

:::callout-tip
この資料のRコマンドを読むときは、どこにスペースがあるかに注意し、自分で書く際も（少なくともはじめのうちは）それを真似するようにしよう。たとえば、上のコマンドの最初の足し算は、`35+87` ではなく、`35 + 87` と書かれている。
:::


通常は、1行に1つのコマンドを書くようにしよう。

Rは大文字と小文字を区別する。したがって、`Var1` と `var1` は異なるモノ（変数、オブジェクト）として認識される。 変数名は英数字と`_` \[アンダースコア\] のみで構成するべきである（日本語も使えるが、トラブルの元なので避けるべき）。ただし、頭文字に数字は使えない。

半角スペースは1つ以上ならいくつあっても1つの半角スペースがある場合と同じである。また、演算子の前後の半角スペースはあってもなくてもよい（コードの読み易さを考えてスペースの有無を決めること）。

::: callout-important
コード中のスペースは**半角**スペースでなければならない。日本語入力で使うスペースは全角スペースだが、全角スペースがあるとコードが正しく動作しないので要注意。プログラミングの際には日本語入力が「オフ」になっていることを確認しよう。
:::

`#`\[ハッシュ\] はコメントの開始として扱われる。 行頭に`#` を書くと、その行すべてがコメントとして扱われる。

```{r}
# 2 * 4  # 行頭からすべてコメント 
```

行の途中に`#` を書くと、`#` 以降がコメントとして扱われる。

```{r}
2 * 4  # これはコメント
```

コメントを書く作業は、コマンドを書く作業と同様に大切である。詳しくは授業で説明する。

Rに用意されている関数の使い方についてヘルプを参照したいときは`?関数名` （または`help(関数名)`)　とする。たとえば、平均値を求める関数 `mean()` のヘルプは、

```{r}
#| eval: false
?mean
```

で確認できる。ウェブブラウザでヘルプを参照したいときは、`help.start()` とする。

インストール済みのパッケージを利用するときは、`library(パッケージ名)` とする。たとえば、**ggplot2** パッケージを使いたいなら、

```{r}
#| eval: false
library(ggplot2)
```

とする。パッケージをインストールする際は、`install.packages("パッケージ名")` とする。その際、どのレポジトリからダウンロードするか尋ねられるので、自分に一番近いところ選ぶ。（パッケージをインストールする度にレポジトリを指定するのが面倒なら、`.Rprofile` であらかじめレポジトリを指定しておく。）

### Rを電卓代わりに使う {#sec-calculator}

Rは電卓の代わりとして使うことができる。 たとえば、

```{r}
1 + 1       # 足し算
100 - 20    # 引き算
5 * 8       # 掛け算
2 / 3       # 割り算
2 ^ 3       # 累乗
sqrt(2)     # 平方根
2 ^ (1 / 2) # sqrt(2) と同じ
```

などの計算ができる。 計算の順番を指定するときは、() で囲めばよい。

```{r}
(5 * (2 + 1)) ^ 3  # (2 + 1) を最初に計算し、それに5を掛けてから最後に三乗する
```

### 変数の利用 {#sec-vars}

Rでは、変数（正確にはオブジェクト）を（ある程度）自由に作ることができる。 変数の名前は自由に決めてよい（ただし、**数字から始まる名前はダメ**。また、`-` \[ハイフン\] はマイナスと区別できないので使えない）。 たとえば、

```{r}
a <- 1
b <- 2
```

とすると、`a`, `b` という2つの変数ができる。ここで `<-` は変数に値を割り当てることを意味する。 （`<-` の代わりに`=` を使うこともできるが混乱の元になるので、変数を定義するときは常に`<-` を使うことにする。）

**`<-` はショートカットキーを使って入力する。**

-   macOS: `option` + `-`（`option` キーと `-`\[マイナス\] キーを同時に押す）
-   Windows: `Alt` + `-`（`Alt` キーと `-` \[マイナス\] キーを同時に押す）

こうすることで、 `<-` だけでなく、その**前後に半角スペースが1つずつ挿入されるので便利**である。つまり、順番に

1.  a
2.  `option` + `-` または `Alt` + `-`
3.  1

と打つと

```{r}
#| eval: false
a <- 1
```

と入力される。ショートカットキーを使わないと、

1.  a
2.  SPACE
3.  \<
4.  \-
5.  SPACE
6.  1

と6段階の入力が必要になる。ショートカットキーを使うことで、これを3回に短縮できる。

定義された変数名のみを入力して実行すると、変数の中身が表示される。

```{r}
a
b
```

この変数は、計算に使える。

```{r}
a + b
a - b
a * b
a / b
b ^ a
```

また、

```{r}
d <- a
a <- 3
```

とすると、$d = 1$, $a = 3$ となる（各自確かめること）。

また、変数名には日本語も使える。 たとえば、

```{r}
変数1 <- 5
変数2 <- 7
変数1 * 変数2
```

とすることも可能である。しかし、変数名に日本語を使うと、（1）英語/日本語の切り替えが面倒であり、（2）文字化け等の予期せぬ問題が生じることがあるので、なるべく日本語の変数名は使わないほうが無難である。

変数の割当と画面への出力を同時に行いたいときは、全体を `()` で囲む。

```{r}
(d <- 3 * 5)
```

変数を消去したいときは`rm()` 関数を使う。

```{r}
rm(d)
```

### ベクトルと行列 {#sec-vector}

#### ベクトル (vectors)

Rで特定のベクトル (vector) を作りたいときは、`c()` を（combine; 結合する）使う （上での変数を作るときに`c` という名前をスキップしたのは、この `c`という名前の関数があるためだった）。 たとえば、1, 2, 3, 4, 5 という5つの数字からなるベクトル **a** を作るには、

```{r}
a <- c(1, 2, 3, 4, 5)
```

とする。このベクトルを画面に表示すると、

```{r}
a
```

となる。

ベクトルの中身は文字列でもかまわない。 たとえば、

```{r}
univ_kochi <- c("KUT", "University of Kochi", "Kochi University")
```

とすれば、文字列 (characters) のベクトルができる。 このように、文字列は引用符（`''` でも`""` でもよい）で囲む。

ひとつひとつの要素を指定する代わりに、様々な方法でベクトルを作ることが可能である。 たとえば、`seq()` 関数（sequence; 数列）を使うと、一連の数字からなるベクトルを作ることができる。

```{r}
seq(1, 20, by = 1)   # 1から20までの整数。1:20 でも同じ
seq(1, 20, by = 2)   # 1から19までの奇数
seq(2, 20, by = 2)   # 2から20までの偶数
seq(20, 1, by = -5)  # 降順、間隔は5
seq(1, 100, length.out = 10) # 最小値が1、最大値が100で、要素の数 (length) が10のベクトル
```

`seq(x, y, by = 1)` の場合はより単純に `x : y`とすればよい。

```{r}
1 : 20
```

また、`rep()`関数（replicate; 複製する）も便利である。

```{r}
rep(3, 10)   # 3が10個のベクトル
rep(c("a", "b", "c"), c(3, 1, 2))  # aが3つ, bが1つ, cが2つのベクトル
```

ベクトルの$i$番目の要素にアクセスするには`ベクトル名[i]`とする。 同時に複数の要素を取り出すこともできる。 たとえば、

```{r}
a <- seq(10, 100, length.out = 10)
b <- 10:1
a[2]
b[2]
a[3:5]
a[c(1,3,5)]
a[c(8, 2, 4)]
```

#### ベクトルの演算

Rでは、ベクトルを使った演算が可能である。 たとえば、次のような計算ができる。

```{r}
x <- 1 : 10
x + 10    # ベクトルxの各要素に10を加える
x - 5     # ベクトルxの各要素から5を引く
x * 2     # ベクトルxの各要素に2をかける
x / 3     # ベクトルxの各要素を3で割る
x ^ 2     # ベクトルxの各要素を2乗する
sqrt(x)   # ベクトルxの各要素の平方根（square root）を計算する
```

また、複数のベクトルを使って、次のような計算ができる。

```{r}
x <- 1:10
y <- -10:-1

# xのi番目の要素とyのi番目の要素を足す（i = 1, 2, ..., 10）
x + y

# xのi番目の要素からyのi番目の要素を引く（i = 1, 2, ..., 10）
x - y

# xのi番目の要素とyのi番目の要素をかける（i = 1, 2, ..., 10）
x * y

# xのi番目の要素をyのi番目の要素で割る（i = 1, 2, ..., 10）
x / y

# xのi番目の要素を「yのi番目の要素」乗にする（i = 1, 2, ..., 10）
x ^ y
```

ベクトル同士の足し算（引き算）をしても、ベクトルの長さは変わらない。

```{r}
length(x)
length(y)
length(x + y)
```

長さの異なるベクトルを使って演算を行うと、短いのほうのベクトルは要素をリサイクルして対応する。

```{r}
x <- 1 : 10
y <- c(100, 200)
x + y
```

ただし、長いほうのベクトルの長さが短いほうのベクトルの長さの整数倍になっていないときは、警告 (warning) が出る。

```{r}
#| warning: true
x <- 1 : 10
y <- c(100, 200, 300)
x + y
```

2つのベクトルの内積 (dot product) は`%*%` で、直積 (outer product) は`%o%` または`outer()` で求められる。

``` {r{}
x <- c(1, 3, 5)
y <- c(10, 20, 30)
x %*% y      # xとyの内積
x %o% y      # xとyの直積
outer(x, y)  # xとyの直積
```

<br>

#### 行列 (matrices)

Rで行列を作るには、`matrix()`関数を使う。 たとえば、

```{r}
(A <- matrix(1 : 9, nrow = 3, byrow = TRUE))
(B <- matrix(1 : 9, nrow = 3, byrow = FALSE))
```

のようにする。 ここで、行列Aと行列Bの違いに注目しよう。 要素全体をひとつの集合としてみると、AとBの行列は全く同じである。 これは、上のコードでは`1 : 9`という部分が同じだからである。 しかし、要素の並び方が異なる。 Aを作ったコードは`byrow = TRUE`となっている。 これは、行 (row) 単位でセルを埋めて行くということである。 それに対し、Bでは`byrow = FALSE` となっている。 これは行単位でセルを埋めない（したがって、列 \[col\] 単位で埋める）ということを意味する。 この違いが、AとBの違いを生み出している。 行列を作るときは行数 `nrow` と列数 `ncol` を指定するが、要素の合計数が決まっているときは、どちらか一方を指定すれば、もう一方は自動的に決められる。 上の例では、要素の数が9で、行の数に3を指定したので、列の数は自動的に 9 / 3 = 3 になっている。

行列の各行と各列にはそれぞれ名前を付けることができる。

```{r}
row.names(A) <- c('row1', 'row2', 'row3')  # 各行に名前をつける
colnames(A) <- c('col1', 'col2', 'col3')   # 各列に名前をつける
A
```

`row.names()`には `.` があり、`colnames()`にはそれがないことに注意。

行列の$i$行$j$列を取り出すには、`行列名[i, j]`とする。 例えば

```{r}
A[1, 3]          # 第1行、第3列の要素を取り出す
A[2, c(1, 3)]    # 第2行で、第1列と第3列の要素を取り出す
A[3, ]           # 第3行の要素をすべて取り出す
A[, 2]           # 第2列の要素をすべて取り出す
```

#### 行列の演算

Rでは行列を使った計算ができる。

基本的な演算の結果は次のとおりである。

```{r}
A <- matrix(1:9, ncol = 3)   　# 行列Aを定義する
B <- matrix(-4:4, ncol = 3)    # 行列Bを定義する
A + 3   # 行列の各要素に3を加える
2 * A   # 行列の各要素を2倍する
A + B   # Aのi行j列要素とBのi行j列要素を足す (i, j = 1, 2, 3)
A * B   # 行列の要素同士の積
A %*% B  # 行列の積
B %*% A  # 行列の積

## AB と BA は異なる
A %*% B == B %*% A  # 要素ごとに等しいかどうか比較する
a <- 1:3  # ベクトルを定義する
A %*% a   # (3行3列) x (3行1列) なので結果は3行1列
```

行列の転置 (transpose) には`t()`を使う。

```{r}
t(A)
```

逆行列は`solve()`で求める。

```{r}
C <- matrix(c(2, 3, 5, 
              7, 11, 13,
              17, 19, 23),
            nrow = 3)
solve(C)
```

特異行列 (a singular matrix) に`solve()` を使うとエラーになる。

```{r}
#| error: true
S <- matrix(1:9, nrow = 3)
solve(S)
```

エラーメッセージを読めば何がまずいのかわかるので、**エラーが出たらエラーメッセージの中身をよく読む**こと。 この場合は、行列が特異行列 (singular) であることを教えてくれている。

:::callout-tip
Rを使っている最中にエラーが出ても何も問題ない。プログラミングを身につけるためには試行錯誤が必要なので、エラーをおそれず、どんどんエラーを出していこう。

エラーが出たら、「自分の意図したとおりに動かず、エラーが出たのはなぜか」を考えよう。エラーの原因を特定することで、プログラミング（R言語）に対する理解が深まるだろう。
:::
